#lang eopl


;concrete & abstract syntax tree & scanner/parser
;=====================================================================

;---concrete syntax tree:

;Program :: = Term

;Term :: = O
;        | true
;        | flase
;        | if Term then Term else Term
;        | succ Term
;        | pred Term
;        | iszero Term


(define scanner-spec
  '((whitespace (whitespace) skip)))
;   (class (regexp) action)
; string (keyword) from grammar-spec (eg: "-","if","let","=",...) has a higher priority than that in scanner-spec.


(define grammar-spec
 '((program (term) a-program)
   (term ("0") zero-tm)
   (term ("true") true-tm)
   (term ("false") false-tm)
   (term ("if" term "then" term "else" term) if-tm)
   (term ("succ" "(" term ")") succ-tm)
   (term ("pred" "(" term ")") pred-tm)
   (term ("iszero" "(" term ")") iszero-tm)))

;---abstract syntax tree

; use auto-generated datatype for program and expression
;(sllgen:make-define-datatypes scanner-spec grammar-spec)

;see what is generated by calling (show-the-datatypes), the result is following:
;(define show-the-datatypes
;  (lambda () (sllgen:list-define-datatypes scanner-spec grammar-spec)))

(define-datatype program program?
  (a-program (a-program1 term?)))

(define-datatype term term?
  (zero-tm)
  (true-tm)
  (false-tm)
  (if-tm (if-tm2 term?) (if-tm3 term?) (if-tm4 term?))
  (succ-tm (succ-tm5 term?))
  (pred-tm (pred-tm6 term?))
  (iszero-tm (iszero-tm7 term?)))

; scan&parse : string -> program
(define scan&parse
  (sllgen:make-string-parser scanner-spec grammar-spec))

; eval
;=====================================================================

;auxiliary : isnum? : trem -> bool
(define isnum?
  (lambda (tm)
    (cases term tm
      (zero-tm () #t)
      (succ-tm (tmx) (isnum? tmx))
      (else #f))))


;eval : term -> term
(define eval
  (lambda (tm)
    (cases term tm
      (if-tm (tm0 tm1 tm2) (let ([condi (eval tm0)])
                               (cond ((equal? condi (true-tm)) (eval tm1))
                                     ((equal? condi (false-tm)) (eval tm2))
                                     (else tm))))
      (succ-tm (tm0) (let ([tmx (eval tm0)])
                       (succ-tm tmx)))
      (pred-tm (tm0) (if (equal? tm0 (zero-tm))
                         (zero-tm)
                         (cases term tm0
                           (succ-tm (tmx) (if (isnum? (eval tmx))
                                              (eval tmx)
                                              (pred-tm (eval tmx))))
                           (else (pred-tm (eval tm0))))))
      (iszero-tm (tm0) (if (equal? tm0 (zero-tm))
                           (true-tm)
                           (cases term tm0
                             (succ-tm (tmx) (if (isnum? tmx)
                                                (false-tm)
                                                (iszero-tm (eval tm0))))
                             (else (iszero-tm (eval tm0))))))
      (else tm))))


; value-of-program : Program -> term
(define value-of-program
  (lambda (pgm)
    (cases program pgm
      (a-program (tm) (eval tm)))))


; run : String -> Expval
(define run
  (lambda (str)
    (value-of-program (scan&parse str))))

; test
;=====================================================================

;> (run "0")
;#(struct:zero-tm)

;> (run "false")
;#(struct:false-tm)

;> (run "succ(0)")
;#(struct:succ-tm #(struct:zero-tm))

;> (run "if true then 0 else succ(0)")
;#(struct:zero-tm)

;> (run "pred(succ(pred(succ(0))))")
;#(struct:zero-tm)

;> (run "if iszero(succ(0)) then true else 0")
;#(struct:zero-tm)